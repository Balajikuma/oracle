INTRODUCTION;

ORACLE OR SQL - BASICS, QUERY LANGUAGE
PLSQL - PROGRAM, PROCEDURAL LANGUAGE
UNIX - AUTOMATE, SCRIPTING LANGUAGE
ONE OF THE BACK END DATABASE APPLICATION.

WHY ORACLE? 
*Buying cost is less  
*Maintenance is cheap  

DEMAND 

DATA TYPES; 
* NUMBER; ONLY NUMERICALS  
 EX: MOBILE NUMBER,PRICE,SALARY, ACC NUMBER  

* VARCHAR; NUMERICALS, ALPHABETICALS, ALPHA NUMERICALS, SPECIAL CHARACTERS
 EX: NAME VARCHAR(20) 
 -UPTO 4000 CHARACTER OR BYTES
 -OCCUPIES SPACE FOR NULL VALUE

* VARCHAR2;NUMERICALS, ALPHABETICALS, ALPHA NUMERICALS, SPECIAL CHARACTERS
 EX: NAME VARCHAR2(20) 
 - UPTO 4000 CHARACTER OR BYTES
 - DOES NOT OCCUPIES SPACE FOR NULL VALUE
 
* CHAR;NUMERICALS, ALPHABETICALS, ALPHA NUMERICALS, SPECIAL CHARACTERS 
 -FIXED LENGTH DATA TYPE
 - NAME CHAR(20)  archana =20
 
SQL STATEMENTS ; 

DML; DATA MANIPULATION LANGUAGE
 * SELECT ; TO OPEN AND VIEW THE OBJECT 
 * INSERT ; TO INSERT THE ENTIRE ROW  
 * DELETE ; TO DELETE THE ENTIRE ROW
 * UPDATE ; TO EDIT THE EXISTING DATA
 
 MANUAL COMMIT; 
 
 CREATE TABLE BATCH_82 (ID NUMBER, NAME VARCHAR(20),LOCATION VARCHAR2(30));

 SELECT * FROM BATCH_82;
 
 1024 COLUMNS
 
 SELECT ID,NAME FROM BATCH_82;
 SELECT LOCATION , ID FROM BATCH_82; 
 SELECT * FROM BATCH82; 
 ORA-00942: table or view does not exist 
 00942. 00000 -  "table or view does not exist" 
 *Cause:
 *Action: Error at Line: 22 Column: 15  
 
 CREATE TABLE BATCH_82 (ID NUMBER, NAME VARCHAR(20),LOCATION VARCHAR2(30));
 Error starting at line : 30 in command - CREATE TABLE BATCH_82 (ID NUMBER, NAME VARCHAR(20),LOCATION VARCHAR2(30))
 Error report - ORA-00955: name is already used by an existing object
 00955. 00000 -  "name is already used by an existing object" 
 *Cause:    
 *Action:
 
INSERT INTO BATCH_82 VALUES (30,'ABI','VELLORE');

SELECT * FROM BATCH_82; 
INSERT INTO BATCH_82 VALUES (30,'ABI','VELLORE',25000); 
Error report - 
SQL Error: ORA-00913: too many values 00913. 00000 -  "too many values" 
*Cause:     
*Action: 

INSERT INTO BATCH_82 VALUES (30,'ABI');  
Error starting at line : 53 in command -

INSERT INTO BATCH_82 VALUES (30,'ABI')
Error at Command Line : 53 Column : 13 Error report - SQL Error: ORA-00947: not enough values
00947. 00000 -  "not enough values"
*Cause:    
*Action:

UPDATE BATCH_82 SET LOCATION='TIRUPUR' WHERE ID=30; 

UPDATE BATCH_82 SET ID=50 WHERE NAME='ANITHA';
DELETE FROM BATCH_82 WHERE NAME='ANANDHI'; 
COMMIT;  
SELECT * FROM BATCH_82; DDL DCL TCL; 
ROWNUM  DATE   SELECT SYSDATE FROM DUAL; 
DESC BATCH_82;

 
DDL;  DATA DEFINITION LANGUAGE
 *CREATE  
 *ALTER
 *ADD
 *DROP
 *RENAME
 *TRUNCATE
 
 AUTO COMMIT ;
 
 SELECT * FROM BATCH_82;
 ALTER TABLE BATCH_82 ADD SALARY NUMBER ;
 ALTER TABLE BATCH_82 ADD ATTENDANCE VARCHAR2(20) DEFAULT 'PRESENT';
 ALTER TABLE BATCH_82 DROP COLUMN SALARY ;
 SELECT SALARY FROM BATCH_82; 
 ORA-00904: 
 "SALARY": invalid identifier 00904. 00000 -  "%s: invalid identifier" *Cause: 
 *Action: Error at Line: 23 Column: 8 
 
ALTER TABLE BATCH_82 RENAME COLUMN LOCATION TO PLACE; 

SELECT LOCATION FROM BATCH_82;

ALTER TABLE BATCH_82 RENAME TO BATCH82;

SELECT * FROM BATCH82;
TRUNCATE TABLE BATCH82;

DROP TABLE BATCH82;

SESSION LEVEL AUTO COMMIT; 

T1           T2 
10R          10R
10R          10R 
ADD     
10R          10R 
             ADD

SHUTDOWN

COMPARISON OPERATORS;

=,<,>,<=,>=,=!,<>

IN 
ANY 
ALL
BETWEEN 

IN;

SELECT * FROM EMPLOYEES WHERE SALARY IN (3000,5000,7000);

EQUALITY CHECK 

SALARY =3000 OR SALARY=5000 OR SALARY=7000

EITHER OR 

IN VS EXIST 

VOLUME = HIGH = EXIST 
VOLUME-LOW=IN 

SELECT * FROM EMPLOYEES WHERE SALARY NOT IN (3000,5000,7000);

ANY;

SELECT * FROM EMPLOYEES WHERE SALARY > ANY  (3000,5000,7000);

SELECT * FROM EMPLOYEES WHERE SALARY > ANY  (3000,5000,24000);

EITHER OR 

SELECT * FROM EMPLOYEES WHERE SALARY = ANY  (3000,5000,7000);

ALL;

SELECT * FROM EMPLOYEES WHERE SALARY > ALL (3000,5000,7000);

AND CONDITION 

SELECT * FROM EMPLOYEES WHERE SALARY > ALL (3000,5000,24000);

SALARY >3000 AND SALARY >5000 AND SALARY >7000




BETWEEN;

TO GET THE RANGE 

SELECT * FROM EMPLOYEES WHERE SALARY BETWEEN 3000 AND  5000;

SELECT * FROM EMPLOYEES WHERE SALARY NOT BETWEEN 3000 AND  5000;


WILDCARD OPERATORS;

LIKE, %, _


SELECT * FROM EMPLOYEES WHERE FIRST_NAME LIKE 'A%';

SELECT * FROM EMPLOYEES WHERE FIRST_NAME LIKE '%a';

SELECT * FROM EMPLOYEES WHERE FIRST_NAME LIKE 'A_';

SELECT * FROM EMPLOYEES WHERE FIRST_NAME LIKE 'A_i_';

SELECT * FROM EMPLOYEES WHERE salary LIKE '24%';


NULL;

NULL IS AN UNKNOWN UNDEFINED VALUE 

ONE NULL IS NOT EQUAL TO ANOTHER NULL

NULL IS NOT EQUAL TO ZERO

DUAL;

DUMMY TABLE 

SELECT 'TIGER' FROM DUAL;

HARDCODING 
LITERALS 

SELECT 'TIGER' FROM EMPLOYEES;

SELECT * FROM DUAL;

DESC DUAL;

SELECT 5+3 FROM DUAL;

  
NULL HANDLING FUNCTIONS ;

NVL
NVL2
NULLIF
COALESCE 

NVL;
NVL (COLUMN_NAME, VALUES)
2 ARGUMENTS OR PARAMETERS 

1.COLUMN NAME 
2.VALUE TO REPLACE THE NULL
SELECT * FROM EMPLOYEES;
SELECT * FROM INSURANCE;

SELECT INSID,NVL (INSID,'NODATA')AS REMARKS FROM INSURANCE;

SELECT INSID,NVL (INSID,0) REMARKS FROM INSURANCE;

NVL2;

 3 ARGUMENTS OR PARAMETERS 

1.COLUMN NAME 
2.VALUE TO REPLACE THE NOT  NULL
3.VALUE TO REPLACE THE NULL

SELECT INSID, NVL2 (INSID,'DATA','NODATA')AS REMARKS FROM INSURANCE;

SELECT INSID, NVL2 (INSID,'PASS','FAIL')AS REMARKS FROM INSURANCE;

NULLIF;

DATA OF 2 COLUMNS =SAME = NULL
DATA OF 2 COLUMNS = NULL= NULL
DATA OF 2 COLUMNS = DIFFERENT VALUES = FIRST COLUMN VALUE 

ONLY 2 COLUMNS CAN BE COMPARED 

2 ARGUMENTS 

SELECT * FROM ADDR;

SELECT ADD1,ADD2,NULLIF(ADD1,ADD2) COMPARE FROM ADDR;


COALESCE;

ANY NUMBER OF COLUMNS CAN BE COMPARED 

IT FETCHES FIRST NOT NULL VALUE 

IT STOPS VALIDATION AFTER FETCHING FIRST NOT NULL VALUE 


NULL NULL 100  3000

SELECT * FROM ADDR;

SELECT ADD1,ADD2,ADD3,COALESCE (ADD1,ADD2,ADD3) RESULT FROM ADDR;

Which null handling function will replace the null value?
ANS - null

JOINS;

INNER JOIN 
LEFT OUTER 
RIGHT OUTER 
FULL OUTER 
CROSS JOIN 
SEMI JOIN 
ANTI JOIN 
EQUI JOIN 
NATURAL JOIN 
SELF JOIN 


N-1

NO OF TABLES -1 = NO OF JOIN CONDITION 

0  0  0  0

SELECT * FROM EMPLOYEE;

SELECT * FROM DEPARTMENT;


SELECT ID,NAME,SALARY,ID,DEPT_NAME
FROM EMPLOYEE INNER JOIN DEPARTMENT
ON ID=ID ;


ORA-00918: column ambiguously defined
00918. 00000 -  "column ambiguously defined"
*Cause:    
*Action:
Error at Line: 28 Column: 7


SELECT EMPLOYEE.ID,EMPLOYEE.NAME,EMPLOYEE.SALARY,DEPARTMENT.ID,DEPARTMENT.DEPT_NAME
FROM EMPLOYEE INNER JOIN DEPARTMENT
ON EMPLOYEE.ID=DEPARTMENT.ID;

TABLE ALIAS

SELECT E.ID,E.NAME,E.SALARY,D.ID,D.DEPT_NAME
FROM EMPLOYEE E INNER JOIN DEPARTMENT D
ON E.ID=D.ID;

SELECT E.ID,E.NAME,E.SALARY,D.ID,D.DEPT_NAME
FROM EMPLOYEE E LEFT OUTER JOIN DEPARTMENT D
ON E.ID=D.ID;

SELECT E.ID,E.NAME,E.SALARY,D.ID,D.DEPT_NAME
FROM EMPLOYEE E RIGHT OUTER JOIN DEPARTMENT D
ON E.ID=D.ID;

SELECT E.ID,E.NAME,E.SALARY,D.ID,D.DEPT_NAME
FROM EMPLOYEE E FULL OUTER JOIN DEPARTMENT D
ON E.ID=D.ID;


SELECT * FROM EMPLOYEES;
DESC EMPLOYEES;
SELECT * FROM DEPARTMENTS;
DESC DEPARTMENTS;
SELECT * FROM LOCATIONS;
DESC LOCATIONS;

EMPTY COLUMN 

NUMBER - VARCHAR 

VARCHAR- NUMBER

SET OPERATORS ;

UNION 
UNION ALL 
INTERSECT 
MINUS 

SELECT * FROM T1;
SELECT * FROM T2;
t1    t2
1     1
0     2
2     3

UNION ;

1 2 0 3 (0 1 2 3 )

FETHCES COMMON DATA FROM BOTH THE TABLE 

UNCOMMON FROM LEFT AND RIGHT TABLE 

SORTING ORDER 

UNION ALL;

1 0 2 1 2 3

IT FETCHES ALL THE DATA FROM BOTH THE TABLE 

NO COMMON AND UNCOMMON VALIDATION IS DONE

INTERSECT ;

1 2

AGGREGATE FUNCTIONS ;

SUM()
MAX()
MIN()
AVG()
COUNT(*) - doesnt ignore null values
COUNT() - it ignores null values
COUNT(1)

SELECT SUM(SALARY) FROM EMPLOYEES;

SELECT MAX(SALARY) FROM EMPLOYEES;

SELECT MIN(SALARY) FROM EMPLOYEES;

SELECT AVG(SALARY) FROM EMPLOYEES;

SELECT COUNT(*) FROM EMPLOYEES;

SELECT COUNT(SALARY) FROM EMPLOYEES;

SELECT COUNT(COMMISSION_PCT)  FROM EMPLOYEES;

SELECT COUNT(10000000) FROM EMPLOYEES;

IT WORKS BASED ON INDEX 


GROUP FUNCTION ;

SELECT MAX(EMPLOYEE_ID),MIN(DEPARTMENT_ID),SUM(SALARY) FROM EMPLOYEES;

SELECT MAX(EMPLOYEE_ID),MIN(DEPARTMENT_ID),MAX(SALARY) FROM EMPLOYEES;
SELECT SALARY,DEPARTMENT_ID FROM EMPLOYEES;
SINGLE ROW OUTPUT
SELECT MAX(SALARY),DEPARTMENT_ID, FIRST_NAME FROM EMPLOYEES GROUP BY FIRST_NAME, DEPARTMENT_ID;

10 
1000
2000
3000
3000

20 

2000
2000
3000
5000
5000



SELECT SUM(SALARY),DEPARTMENT_ID,SALARY FROM EMPLOYEES GROUP BY DEPARTMENT_ID,SALARY;


SELECT SUM(SALARY),DEPARTMENT_ID,SALARY FROM EMPLOYEES GROUP BY DEPARTMENT_ID,SALARY
WHERE DEPARTMENT_ID > 70;

ORA-00933: SQL command not properly ended
00933. 00000 -  "SQL command not properly ended"
*Cause:    
*Action:
Error at Line: 59 Column: 1


SELECT SUM(SALARY),DEPARTMENT_ID,SALARY FROM EMPLOYEES WHERE SALARY > 8000 
GROUP BY DEPARTMENT_ID,SALARY
HAVING DEPARTMENT_ID >70 AND SUM(SALARY) > 25000;

ANALYTICAL FUNCTION ;

TO RANK THE RECORD ;

RANK()
DENSE_RANK()
ROW_NUMBER()
LEAD
LAG 


ORDER BY ;

SELECT * FROM EMPLOYEES ORDER BY SALARY; /* Ascending Order */

SELECT * FROM EMPLOYEES ORDER BY SALARY DESC,EMPLOYEE_ID DESC;

ISHAN.G DOB
ISHAN.G 

SELECT * FROM EMPLOYEES ORDER BY 2;

SELECT FIRST_NAME,LAST_NAME,EMPLOYEE_ID,SALARY FROM EMPLOYEES ORDER BY 1;

SELECT SALARY FROM EMPLOYEES ORDER BY SALARY;
SELECT SALARY, RANK() OVER (ORDER BY SALARY) FROM EMPLOYEES;

SELECT SALARY , RANK() OVER (ORDER BY SALARY DESC)RANKING FROM EMPLOYEES;

IT SKIPS CONSECUTIVE NUMBER 

SELECT SALARY , DENSE_RANK() OVER (ORDER BY SALARY DESC)RANKING FROM EMPLOYEES;

IT DOESNT SKIP CONSECUTIVE NUMBER

SELECT SALARY , DENSE_RANK() OVER (ORDER BY SALARY DESC)RANKING FROM EMPLOYEES;

ROW_NUMBER()
SELECT SALARY, ROW_NUMBER() OVER (ORDER BY SALARY DESC)RANKING FROM EMPLOYEES;

IT ASSIGNS NUMBER FOR EACH ROW IN SEQUENTIAL ORDER ;

LEAD;
SELECT EMPLOYEE_ID, FIRST_NAME,SALARY, LEAD (SALARY,1) OVER (ORDER BY SALARY ) FROM EMPLOYEES;

CEO
DIRECTOR
MANAGER 
ASSIS MANAGER 

SELECT FIRST_NAME,SALARY, LEAD (SALARY,3) OVER (ORDER BY SALARY ) FROM EMPLOYEES;

SELECT FIRST_NAME,SALARY, LEAD (SALARY,1,0) OVER (ORDER BY SALARY ) FROM EMPLOYEES;

SELECT FIRST_NAME,SALARY, LEAD (SALARY,3,0) OVER (ORDER BY SALARY DESC ) FROM EMPLOYEES;

SELECT FIRST_NAME,SALARY, LAG (SALARY,1) OVER (ORDER BY SALARY ) FROM EMPLOYEES;

SELECT FIRST_NAME,SALARY, LAG (SALARY,1,0) OVER (ORDER BY SALARY ) FROM EMPLOYEES;

SELECT FIRST_NAME,SALARY, LAG (SALARY,5) OVER (ORDER BY SALARY ) FROM EMPLOYEES;

SLAB EQUALIZE

SELECT DEPARTMENT_ID,SALARY,RANK() OVER 
(PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC)RANKING FROM EMPLOYEES;

MULTIPLE ROW OUTPUT 

SELECT DEPARTMENT_ID,SALARY,RANK() OVER 
(PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC)RANKING FROM EMPLOYEES
WHERE RANKING = 1;

ORA-00904: "RANKING": invalid identifier
00904. 00000 -  "%s: invalid identifier"
*Cause:    
*Action:
Error at Line: 8 Column: 7
SELECT DEPARTMENT_ID,SALARY,RANK() OVER 
(PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC)RANKING FROM EMPLOYEES;



TEMPORARY TABLE 

WITH CLAUSE ;

2 SELECT QUERY 


WITH TAB AS 
(SELECT DEPARTMENT_ID,SALARY,RANK() OVER 
(PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC)RANKING FROM EMPLOYEES)
SELECT * FROM TAB WHERE RANKING=1;


DISTINCT;

SELECT DEPARTMENT_ID FROM EMPLOYEES;

SELECT DISTINCT DEPARTMENT_ID FROM EMPLOYEES;

SELECT DISTINCT DEPARTMENT_ID,SALARY FROM EMPLOYEES;
SELECT DEPARTMENT_ID,COUNT(*) FROM EMPLOYEES WHERE DEPARTMENT_ID IN (10,20,30) 
GROUP BY DEPARTMENT_ID;

SELECT DEPARTMENT_ID ,COUNT(*) OVER (PARTITION BY DEPARTMENT_ID )RR FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (10,20,30);

CTAS;

CREATE TABLE AS SELECT ;

SELECT EMPLOYEE_ID,FIRST_NAME FROM EMPLOYEES;

CREATE TABLE B82_CTAS AS 
(SELECT EMPLOYEE_ID,FIRST_NAME FROM EMPLOYEES);

SELECT * FROM B82_CTAS;

DROP TABLE B82_CTAS;

CREATE TABLE B82_CTAS AS 
(SELECT EMPLOYEE_ID,FIRST_NAME FROM EMPLOYEES WHERE 1=2);

LEVEL;

ONE OF THE PSEUDO COLUMN 

NOT AN ORIGINAL COLUMN 

IMAGINARY COLUMN 

LEVEL CANNOT BE A COLUMN NAME 

SELECT LEVEL FROM DUAL;

ORA-01788: CONNECT BY clause required in this query block
01788. 00000 -  "CONNECT BY clause required in this query block"
*Cause:    
*Action:
Error at Line: 11 Column: 19

1.CONNECT BY CLAUSE 
2. OPERATOR SIGN <,<=
3. NUMERICAL 


SELECT LEVEL FROM DUAL CONNECT BY LEVEL <= 10;

CREATE TABLE LEV_82 AS
SELECT LEVEL FROM DUAL CONNECT BY LEVEL <= 10;

Error starting at line : 26 in command -
CREATE TABLE LEV_82 AS
SELECT LEVEL FROM DUAL CONNECT BY LEVEL <= 10
Error report -
ORA-00998: must name this expression with a column alias
00998. 00000 -  "must name this expression with a column alias"
*Cause:    
*Action:


CREATE TABLE LEV_82 AS
SELECT LEVEL ID FROM DUAL CONNECT BY LEVEL <= 10;

SELECT * FROM LEV_82;

NUMBER FUNCTIONS;

ROUND 
TRUNC
MOD

SELECT ROUND(198.9), ROUND(123.3) FROM DUAL;

SELECT TRUNC(198.9), TRUNC(123.3) FROM DUAL;

SELECT MOD(8,3),MOD(1,0) FROM DUAL;

CASE;

TO CATEGORIZE THE RECORD;

SELECT FIRST_NAME,SALARY,CASE WHEN SALARY >15000 THEN 'MANAGER'
WHEN SALARY BETWEEN 10000 AND 15000 THEN 'LEAD' 
ELSE 'DEVELOPER'
END AS DESIGNATION
FROM EMPLOYEES;

SELECT FIRST_NAME,SALARY,CASE WHEN SALARY >15000 THEN 'MANAGER'
WHEN SALARY BETWEEN 10000 AND 15000 THEN 'LEAD' 
END AS DESIGNATION
FROM EMPLOYEES;
DECODE;

SELECT FIRST_NAME,SALARY,DECODE (SALARY,24000,'MANAGER',17000,'LEAD','DEVELOPER')
FROM EMPLOYEES;

SELECT FIRST_NAME,SALARY,DECODE (SALARY,24000,'MANAGER',17000,'LEAD')
FROM EMPLOYEES;

SELECT CASE WHEN NULL=NULL
THEN 'A' ELSE 'B'
END
FROM DUAL;

SELECT DECODE (NULL,NULL,'A','B') FROM DUAL;

SELECT DECODE (NULL,null,'A','B') FROM DUAL;

SELECT DECODE (NULL,'TIGER','A','B') FROM DUAL;

SELECT DECODE ('TIGER','TIGER','A','B') FROM DUAL;

SELECT DECODE ('TIGER','tiger','A','B') FROM DUAL;
